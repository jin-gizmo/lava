#!/usr/bin/env python3

"""
Extract AWS logs from Cloudwatch.

.. warning::
    This is really old code. The way it has been implemented makes very little
    sense. You know it. I know it. Original intention was to depend on nothing
    other than the AWS CLI. However, it works and I can't be bothered rewriting
    it. All that's been done when addiing it into the lava AMI build is to
    remove Python 2 support and fix some of the more egregious quality errors.

Copyright (c) 2016, Murray Andrews
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation and/or
    other materials provided with the distribution.

3.  Neither the name of the copyright holder nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""

from __future__ import annotations

import argparse
import datetime
import json
import logging
import re
import subprocess
import sys
from collections.abc import Iterator
from os.path import basename
from typing import Any

AWS = 'aws'  # AWS command

# Standard AWS CLI args we accept.
# These take no arguments
AWS_ARGS_0 = ('debug',)
# These take 1 argument
AWS_ARGS_1 = ('profile', 'region', 'cli-connect-timeout', 'cli-read-timeout')

PROG = basename(sys.argv[0])
LOG = logging.getLogger()
COLOUR = True

EVENT_PRINT_FORMAT = '{B}{s}\t{t.iso}{X}\t{m}'
DEFAULT_TIME_WINDOW = '30m'  # Show this much log history

# ------------------------------------------------------------------------------
# Clunky support for colour output if colorama is not installed.

try:
    # noinspection PyUnresolvedReferences
    import colorama

    # noinspection PyUnresolvedReferences
    from colorama import Fore, Style

    colorama.init()

except ImportError:

    class Fore:
        """Basic alternative to colorama colours using ANSI sequences."""

        RESET = '\033[0m'
        BLACK = '\033[30m'
        RED = '\033[31m'
        GREEN = '\033[32m'
        YELLOW = '\033[33m'
        BLUE = '\033[34m'
        MAGENTA = '\033[35m'
        CYAN = '\033[36m'

    class Style:
        """Basic alternative to colorama styles using ANSI sequences."""

        RESET_ALL = '\033[0m'
        BRIGHT = '\033[1m'
        DIM = '\033[2m'
        NORMAL = '\033[22m'


# ------------------------------------------------------------------------------
def get_log_level(s: str) -> int:
    """
    Convert the string version of a log level corresponding log level.

    Raises ValueError if a bad string is provided.

    :param s:       A string version of a log level (e.g. 'error', 'info').
                    Case is not significant.

    :return:        The numeric logLevel equivalent.

    :raises:        ValueError if the supplied string cannot be converted.
    """

    if not s or not isinstance(s, str):
        raise ValueError('Bad log level:' + str(s))

    t = s.upper()

    if not hasattr(logging, t):
        raise ValueError('Bad log level: ' + s)

    return getattr(logging, t)


# ------------------------------------------------------------------------------
TIME_UNITS = {
    'w': 60 * 60 * 24 * 7,
    'd': 60 * 60 * 24,
    'h': 60 * 60,
    'm': 60,
    's': 1,
    '': 1,  # Default is seconds
}

DURATION_REGEX = (
    r'\s*((?P<value>[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)\s*(?P<units>[{units}]?))\s*$'.format(
        units=''.join(TIME_UNITS.keys())
    )
)


# ------------------------------------------------------------------------------
def duration_to_seconds(duration: str | int | float) -> float:
    """
    Convert a string specifying a time duration to a number of seconds.

    :param duration:    String in the form nnnX where nnn is an integer or float
                        and X is one of (case sensitive):
                        'w':    weeks
                        'd':    days
                        'h':    hours
                        'm':    minutes
                        's':    seconds.

                        If X is missing then seconds are assumed. Whitespace is ignored.
                        Can also be a float or integer. Note a leading + or - will be
                        handled correctly as will exponentials.

    :return:            The duration in seconds.

    :raise ValueError:  If the duration is malformed.
    """

    if isinstance(duration, (int, float)):
        return float(duration)

    if not isinstance(duration, str):
        raise ValueError(f'Invalid duration type: {type(duration)}')

    m = re.match(DURATION_REGEX, duration)
    if not m:
        raise ValueError('Invalid duration: ' + duration)

    return float(m.group('value')) * TIME_UNITS[m.group('units')]


# ------------------------------------------------------------------------------
class ColourLogHandler(logging.Handler):
    """Basic stream handler that writes to stderr with colours for different log levels."""

    # --------------------------------------------------------------------------
    def __init__(self, colour: bool = True):
        """
        Allow colour to be enabled or disabled.

        :param colour:      If True colour is enabled for log messages.
                            Default True.

        """

        super().__init__()
        self.colour = colour

    # --------------------------------------------------------------------------
    def emit(self, record: logging.LogRecord) -> None:
        """
        Print the record to stderr with some colour enhancement.

        :param record:  Log record
        """

        if self.colour:
            if record.levelno >= logging.ERROR:
                colour = Style.BRIGHT + Fore.RED
            elif record.levelno >= logging.WARNING:
                colour = Fore.MAGENTA
            elif record.levelno >= logging.INFO:
                colour = Fore.BLACK
            else:
                colour = Style.DIM + Fore.BLACK

            print(
                colour + PROG + ': ' + self.format(record) + Fore.RESET + Style.RESET_ALL,
                file=sys.stderr,
            )
        else:
            print(PROG + ': ' + self.format(record), file=sys.stderr)


# ------------------------------------------------------------------------------
def cprint(colour, *args, **kwargs) -> None:
    """
    Print in colour if colour printing is enabled.

    :param colour:  A colour activation sequence (e.g. Fore.RED)
    :param args:    Normal print() positional args.
    :param kwargs:  Normal print() keyword args.

    """

    if COLOUR:
        print(colour, end='')
    print(*args, end='', **kwargs)
    if COLOUR:
        print(Fore.RESET)
    else:
        print('')


# ------------------------------------------------------------------------------
class AwsContext:
    """A context for running AWS CLI commands."""

    # --------------------------------------------------------------------------
    def __init__(self, aws_args: list[str] = None):
        """
        Init.

        :param aws_args:    An optional list of AWS CLI args added to each
                            command. (e.g. --profile).
        :type aws_args:     list[str]
        :return:
        """

        self.aws_args = aws_args

    # --------------------------------------------------------------------------
    def __call__(self, *args: str | list[str] | dict[str, Any], **kwargs: dict) -> dict[str, Any]:
        """
        Run an AWS CLI command, process the JSON response and return the response data.

        :param args:    Each arg can be a string, a list of strings or a dict
        :param kwargs:  Keyword to add to the command.

        :return:        The JSON structure returned by the command.

        :raise CalledProcessError: If the CLI call fails. The retcode and
                        output properties of the exception may be helpful.
        :raise ValueError: If an invalid argument type is supplied.
        :raise Exception: Various JSON decode errors if the CLI call returns
                        invalid JSON. This should really not happen.
        """

        cmd = ['aws']

        for arg in args:
            if arg is None:
                continue

            # noinspection PyUnresolvedReferences
            if isinstance(arg, str):
                cmd.append(arg)
            elif isinstance(arg, (int, float)):
                cmd.append(str(arg))
            elif isinstance(arg, list):
                cmd.extend([str(x) for x in arg])
            elif isinstance(arg, dict):
                for k in arg:
                    if arg[k] is not None:
                        cmd.extend([k, str(arg[k])])
            else:
                raise ValueError(f'Invalid arg type {type(arg)}: {arg}')

        for k in kwargs:
            if kwargs[k] is not None:
                cmd.extend([k, kwargs[k]])

        # Add in the common arguments
        cmd.extend(self.aws_args)

        LOG.debug('Run: %s', ' '.join(cmd))
        try:
            resp_json = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        except subprocess.CalledProcessError as e:
            LOG.debug('Fail: %s', ' '.join(cmd))
            LOG.debug('      Retcode=%d', e.returncode)
            LOG.debug('      Output =%s', e.output)
            raise

        LOG.debug('Done: %s', ' '.join(cmd))

        # Python 2 str has decode function, Python 3 str does not. Grr.
        return json.loads(resp_json.decode('utf-8') if isinstance(resp_json, bytes) else resp_json)

    # --------------------------------------------------------------------------
    @staticmethod
    def filters(filters: dict[str, str | list[str]] = None) -> list[str]:
        """
        Convert a dictionary into a list of filter args suitable for use in an aws CLI command.

        :param filters:     Dictionary of filter keys/values. Values can be strings
                            or lists of strings.
        :return:            A list of filter args (including the --filter preamble).
        :rtype:             list[str]
        """

        if not filters:
            return []

        return ['--filter'] + [
            'Name={},Values={}'.format(k, v if isinstance(v, str) else ','.join(v))
            for k, v in filters.items()
        ]

    # --------------------------------------------------------------------------
    def log_groups(self) -> Iterator[dict[str, Any]]:
        """
        Get all log group objects.

        Handles result pagination.

        :return:        A generator of log group objects as per the AWS CLI
        """

        start_token = None
        while True:
            result = self('logs', 'describe-log-groups', {'--starting-token': start_token})
            start_token = result.get('NextToken')
            yield from result['logGroups']
            if not start_token:
                break

    # --------------------------------------------------------------------------
    def log_streams(self, log_group: str, stream_prefix: str = None) -> Iterator[dict[str, Any]]:
        """
        Get log streams in the specified group.

        Handles result pagination.

        :param log_group:       Log group name.
        :param stream_prefix:   If not None then only streams with this prefix
                                are returned.
        :return:                A generator for log stream objects.
        """

        pfx = {'--log-stream-name-prefix': stream_prefix}

        start_token = None
        result = None
        while True:
            try:
                result = self(
                    'logs',
                    'describe-log-streams',
                    '--log-group-name',
                    log_group,
                    pfx,
                    {'--starting-token': start_token},
                )
            except subprocess.CalledProcessError as e:
                if 'ResourceNotFoundException' in str(e.output):
                    raise Exception(f'No such log group: {log_group}')

            start_token = result.get('NextToken')
            yield from result['logStreams']
            if not start_token:
                break

    # ------------------------------------------------------------------------------
    def log_events(self, log_group, log_stream, start_time=None, end_time=None):
        """
        Get events on the specified log stream.

        Handles result pagination.

        :param log_group:   Log group name.
        :param log_stream:  Log stream name.
        :param start_time:  Start time for events as millisceconds since the epoch.
                            UTC. Default None.
        :param end_time:    End time for events as millisceconds since the epoch.
                            UTC. Default None.
        :type log_group:    str
        :type log_stream:   str
        :type start_time:   int
        :type end_time:     int
        :return:            A generator for events
        """

        time_args = {}
        if start_time:
            time_args['--start-time'] = start_time
        if end_time:
            time_args['--end-time'] = end_time

        start_from_head = '--start-from-head'
        next_token = None
        next_token_prev = None
        while True:
            result = self(
                'logs',
                'get-log-events',
                '--log-group-name',
                log_group,
                '--log-stream-name',
                log_stream,
                {'--next-token': next_token},
                time_args,
                start_from_head,
            )
            start_from_head = None
            next_token = result.get('nextForwardToken')
            if len(result['events']) == 0:
                if next_token_prev == next_token:
                    break
                next_token_prev = next_token
                continue
            yield from result['events']

    # ------------------------------------------------------------------------------
    def find_log_stream(self, log_stream, log_group=None):
        """
        Look for a CloudWatch log stream with the specified name.

        :param log_stream:  Log stream name.
        :param log_group:   Log group name. If not specified then all log groups
                            will be searched and the stream with the latest event
                            timestamp will be returned. This is possible if the same
                            stream name occurs in multiple log groups. Default None.

        :type log_stream:   str
        :type log_group:    str
        :return:            The name of the parent log group or None if the stream
                            is not found.
        :rtype:             str
        """

        groups = [log_group] if log_group else [g['logGroupName'] for g in self.log_groups()]

        last_event_time = 0
        found_group = None

        for grp_name in groups:
            for s in self.log_streams(grp_name, stream_prefix=log_stream):
                if (
                    s['logStreamName'] == log_stream
                    and s.get('lastEventTimestamp', -1) > last_event_time
                ):
                    # Found a matching stream
                    found_group = grp_name
                    last_event_time = s.get('lastEventTimestamp', -1)

        return found_group

    # ------------------------------------------------------------------------------
    def get_instances_by_name(self, instance_name):
        """
        Find all instances with the given name.

        :param instance_name:   The instance name (i.e. value of Name tag).
        :type instance_name:    str

        :return:    A dictionary of instance records (keyed on instance ID).
        :rtype:     dict
        """

        instances = {}
        result = self(
            'ec2',
            '--no-paginate',
            'describe-instances',
            self.__class__.filters({'tag:Name': instance_name}),
        )

        for r in result['Reservations']:
            for i in r['Instances']:
                instances[i['InstanceId']] = i

        return instances

    # ------------------------------------------------------------------------------
    def get_interfaces_by_ip(self, ip_address: str, addr_type: str = 'private') -> dict[str, Any]:
        """
        Get interfaces with the specified IP.

        Note that it is possible for one address to be associated with multiple
        interfaces if there are multiple VPCs.

        :param ip_address:  An IP4 address as a string.
        :param addr_type:   The type of address - must be 'public' or 'private'.
                            Default 'private'.

        :return:    A dictionary of interface objects (keyed on interface ID).
        """

        if addr_type not in ('public', 'private'):
            raise ValueError(f'Bad address type: {addr_type}')

        filter_name = (
            'addresses.private-ip-address' if addr_type == 'private' else 'association.public-ip'
        )

        result = self(
            'ec2',
            'describe-network-interfaces',
            '--no-paginate',
            self.__class__.filters({filter_name: ip_address}),
        )

        return {i['NetworkInterfaceId']: i for i in result['NetworkInterfaces']}

    # ------------------------------------------------------------------------------
    def get_interfaces_by_name(self, eni_name: str) -> dict[str, Any]:
        """
        Get interfaces with the specified name.

        :param eni_name:    ENI name (value of Name tag)

        :return:    A dictionary of interface objects (keyed on interface ID).
        """

        result = self(
            'ec2',
            'describe-network-interfaces',
            '--no-paginate',
            self.__class__.filters({'tag:Name': eni_name}),
        )

        return {i['NetworkInterfaceId']: i for i in result['NetworkInterfaces']}


# ------------------------------------------------------------------------------
def setup_logging(level: str, target: str, colour: bool = True) -> None:
    """
    Set up logging.

    :param level:   Logging level. The string format of a level (eg 'debug').
    :param target:  Logging target. Either a file name or a syslog facility name
                    starting with @ or None.
    :param colour:  If True and logging to the terminal, colourise messages for
                    different logging levels. Default True.

    :raise ValueError: If an invalid log level or syslog facility is specified.
    """

    LOG.setLevel(get_log_level(level))
    if target:
        for h in LOG.handlers:
            LOG.removeHandler(h)

        # Log to a file
        h = logging.FileHandler(target)
        h.setFormatter(logging.Formatter('%(asctime)s: %(levelname)s: %(message)s'))
        LOG.addHandler(h)
        LOG.debug('%s', ' '.join(sys.argv))
        LOG.debug('Logfile set to %s', target)
    else:
        # Just log to stderr.
        LOG.addHandler(ColourLogHandler(colour=colour))
    LOG.debug('Log level set to %s', LOG.getEffectiveLevel())


# ------------------------------------------------------------------------------
def list_streams(aws_context: AwsContext, log_group: str = None) -> None:
    """
    List the available log streams.

    :param aws_context:     AWS connection context.
    :param log_group:       CloudWatch log group. If None then search all
                            available groups.
    """

    log_groups = (
        [log_group] if log_group else sorted([g['logGroupName'] for g in aws_context.log_groups()])
    )

    for g in log_groups:
        cprint(Fore.BLUE, g)
        for s in aws_context.log_streams(g):
            print(f'    {s["logStreamName"]}')


# ------------------------------------------------------------------------------
class Timestamp:
    """
    Convenience class for extracting various time elements from a timestamp.

    Any of the directives supported by strftime() can be used as an instance
    attribute. e.g. Timestamp.A will return the weekday as locale's full name.

    """

    DATETIME_FORMATS = [
        '%Y-%m-%dT%H:%M:%S',  # ISO-8601 like
        '%Y-%m-%dT%H:%M',  # ISO-8601 like - no seconds
        '%Y-%m-%d %H:%M:%S',  # ISO-8601 like - No T
        '%Y-%m-%d %H:%M',  # ISO-8601 like - No T and no seconds
        '%Y%m%d %H:%M:%S',  # 20161225 10:10:10
        '%Y%m%d %H:%M',  # 20161225 10:10
    ]

    # --------------------------------------------------------------------------
    @staticmethod
    def dt_to_ms(dt: datetime.datetime) -> int:
        """
        Convert a datetime to a number of milliseconds since the epoch.

        :param dt:  A datetime
        :return:    Current time as number of milliseconds since the epoch.

        """

        return int(dt.timestamp() * 1000)

    # --------------------------------------------------------------------------
    @classmethod
    def tspec_to_dt(cls, time_spec: str) -> datetime.datetime:
        """
        Convert a time spec to a datetime.

        A time spec can be:

        -   A duration (e.g. 24h) meaning that amount of time prior to the
            current time.
        -   One of the formats specified in DATETIME_FORMATS

        :param time_spec:   A time spec.

        :return:            A datetime.

        :raise ValueError:  If the time spec cannot be converted.
        """

        try:
            return datetime.datetime.now() - datetime.timedelta(
                seconds=duration_to_seconds(time_spec)
            )
        except ValueError:
            # Doesn't appear to be a duration spec. Try something else.
            pass

        for date_format in cls.DATETIME_FORMATS:
            try:
                return datetime.datetime.strptime(time_spec, date_format)
            except ValueError:
                # Not the right format - keep trying.
                pass
        raise ValueError(f'Cannot parse time spec: {time_spec}')

    # --------------------------------------------------------------------------
    def __init__(self, t: int | str = None):
        """
        Init.

        :param t:       One of the following:

                        - Milliseconds since the epoch.
                        - A duration string (e.g. 24h) meaning that period of
                          time before now.
                        - A date-like string (see DATETIME_FORMATS)
                        - A datetime
                        - None - meaning current time.
        """

        if not t:
            t = datetime.datetime.now()

        if isinstance(t, datetime.datetime):
            self._dt = t
            self._ts = self.__class__.dt_to_ms(t)
        if isinstance(t, int):
            self._ts = t
            self._dt = datetime.datetime.fromtimestamp(t / 1000.0)
        elif isinstance(t, str):
            self._dt = self.__class__.tspec_to_dt(t)
            self._ts = self.__class__.dt_to_ms(self._dt)

    # --------------------------------------------------------------------------
    def __eq__(self, other) -> bool:
        """
        Compare timestamp values.

        :param other:   Other Timestamp.
        :type other:    Timestamp
        """

        return self._ts == other._ts  # noqa SLF001

    # --------------------------------------------------------------------------
    def __lt__(self, other) -> bool:
        """
        Compare timestamp values.

        :param other:   Other Timestamp.
        :type other:    Timestamp
        """

        return self._ts < other._ts  # noqa SLF001

    # --------------------------------------------------------------------------
    @property
    def milliseconds(self) -> int:
        """The timestamp as milliseconds from the epoch."""

        return self._ts

    # --------------------------------------------------------------------------
    @property
    def datetime(self) -> datetime.datetime:
        """The timestamp as a datetime."""

        return self._dt

    # --------------------------------------------------------------------------
    def __getattr__(self, item: str) -> str:
        """
        Any of the directives supported by strftime() can be used as an instance attribute.

        e.g. Timestamp.A will return the weekday as locale's full name.

        :param item:    Attribute name.
        :return:        The strftime result of the directive %item.
        """

        return self._dt.strftime('%' + item)

    # --------------------------------------------------------------------------
    def __str__(self) -> str:
        """Convert timestamp to a string."""

        return str(self._ts)

    # --------------------------------------------------------------------------
    @property
    def ctime(self) -> str:
        """Convert timestamp to ctime format."""

        return self._dt.ctime()

    # --------------------------------------------------------------------------
    @property
    def iso(self) -> str:
        """The timestamp formatted as ISO 8601."""

        return self._dt.isoformat()


# ------------------------------------------------------------------------------
def process_event(event: dict[str, Any], log_group: str, log_stream: str) -> None:
    """
    Decode the timestamps in an event.

    Also adds some fields to allow selective parts of the event to be printed
    easily.

    :param event:       A dict containing an event record.
    :param log_group:   Log group name.
    :param log_stream:  Log stream name.

    """

    event['g'] = log_group
    event['s'] = log_stream
    event['m'] = event['message']
    event['i'] = Timestamp(event['ingestionTime'])
    event['t'] = Timestamp(event['timestamp'])


# ------------------------------------------------------------------------------
def print_event(event: dict[str, Any], log_group: str, log_stream: str, fmt: str):
    """
    Print an event record using the specified format.

    :param event:       A dict containing an event record.
    :param log_group:   Log group name.
    :param log_stream:  Log stream name.
    :param fmt:         A format string.
    """

    process_event(event, log_group, log_stream)
    try:
        # Note the +{X} forces a colour reset at end of each line.
        print(
            (fmt + '{X}').format(
                X=Fore.RESET if COLOUR else '',
                K=Fore.BLACK if COLOUR else '',
                R=Fore.RED if COLOUR else '',
                G=Fore.GREEN if COLOUR else '',
                Y=Fore.YELLOW if COLOUR else '',
                B=Fore.BLUE if COLOUR else '',
                M=Fore.MAGENTA if COLOUR else '',
                C=Fore.CYAN if COLOUR else '',
                **event,
            )
        )
    except KeyError as e:
        raise Exception(f'Invalid event format key: {e.args[0]}')


# ------------------------------------------------------------------------------
def print_stream(
    log_stream: str,
    aws_context: AwsContext,
    fmt: str,
    log_group: str = None,
    regex: str = None,
    not_regex: str = None,
    start_time: Timestamp = None,
    end_time: Timestamp = None,
) -> None:
    """
    Print log events from a log stream.

    :param log_stream:  Log stream name.
    :param aws_context: AWS connection context.
    :param fmt:         A format string
    :param log_group:   Log group name. If None (default) search all log groups.
    :param regex:       Only print events whose message matches the regex. If
                        None, all events are selected. Default None
    :param not_regex:   Don't print events whose message matches the regex.
                        Default None.
    :param start_time:  Start time timestamp. Default None.
    :param end_time:    Timestamp for end time for events to print. Default None.

    """

    log_group = aws_context.find_log_stream(log_stream, log_group=log_group)
    if not log_group:
        raise Exception(f'No such log stream: {log_stream}')

    LOG.debug('Found stream %s in group %s', log_stream, log_group)

    re_yes = re.compile(regex) if regex else None
    re_no = re.compile(not_regex) if not_regex else None

    for event in aws_context.log_events(
        log_group, log_stream, start_time.milliseconds, end_time.milliseconds
    ):
        if (not re_yes or re_yes.search(event['message'])) and (
            not re_no or not re_no.search(event['message'])
        ):
            print_event(event, log_group, log_stream, fmt)


# ------------------------------------------------------------------------------
def print_instance_log(
    instance_name: str,
    aws_context: AwsContext,
    fmt: str,
    log_group: str = None,
    regex: str = None,
    not_regex: str = None,
    start_time: Timestamp = None,
    end_time: Timestamp = None,
) -> None:
    """
    Print log events for instances with the specified name.

    If more than one instance has the same name then the logs are printed one
    after another, not merged.

    :param instance_name: Name of an EC2 instance (i.e. value of Name tag).
    :param aws_context: AWS connection context.
    :param fmt:         A format string
    :param log_group:   Log group name. If None (default) search all log groups.
    :param regex:       Only print events whose message matches the regex. If
                        None, all events are selected. Default None.
    :param not_regex:   Don't print events whose message matches the regex.
                        Default None.
    :param start_time:  Start time timestamp. Default None.
    :param end_time:    Timestamp for end time for events to print. Default None.

    """

    instances = aws_context.get_instances_by_name(instance_name)
    if not instances:
        raise Exception(f'No instances named "{instance_name}" found')

    for i in sorted(instances):
        print_stream(
            i,
            aws_context,
            fmt,
            log_group=log_group,
            regex=regex,
            not_regex=not_regex,
            start_time=start_time,
            end_time=end_time,
        )


# ------------------------------------------------------------------------------
def print_instance_net(
    instance_name: str,
    aws_context: AwsContext,
    fmt: str,
    log_group: str = None,
    regex: str = None,
    not_regex: str = None,
    start_time: Timestamp = None,
    end_time: Timestamp = None,
) -> None:
    """
    Print log events for the network interfaces of instances with the specified name.

    If more than one instance has the same name then the logs are printed
    one after another, not merged. This relies on flowlogs being enabled.

    :param instance_name: Name of an EC2 instance (i.e. value of Name tag).
    :param aws_context: AWS connection context.
    :param fmt:         A format string
    :param log_group:   Log group name. If None (default) search all log groups.
    :param regex:       Only print events whose message matches the regex. If
                        None, all events are selected. Default None.
    :param not_regex:   Don't print events whose message matches the regex.
                        Default None.
    :param start_time:  Start time timestamp. Default None.
    :param end_time:    Timestamp for end time for events to print. Default None.

    """

    instances = aws_context.get_instances_by_name(instance_name)

    if not instances:
        raise Exception(f'No instances named "{instance_name}" found')

    for i in sorted(instances):
        for interface in instances[i]['NetworkInterfaces']:
            print_stream(
                interface['NetworkInterfaceId'] + '-all',
                aws_context,
                fmt,
                log_group=log_group,
                regex=regex,
                not_regex=not_regex,
                start_time=start_time,
                end_time=end_time,
            )


# ------------------------------------------------------------------------------
def print_ip_log(
    ip_address: str,
    aws_context: AwsContext,
    fmt: str,
    log_group: str = None,
    regex: str = None,
    not_regex: str = None,
    start_time: Timestamp = None,
    end_time: Timestamp = None,
) -> None:
    """
    Print log events for network interfaces with the given public or private IP address.

    Note that a private IP may be associated with multiple interfaces if there
    are multiple VPCs

    :param ip_address:  IP address (as a string). May be public or private IP.
    :param aws_context: AWS connection context.
    :param fmt:         A format string
    :param log_group:   Log group name. If None (default) search all log groups.
    :param regex:       Only print events whose message matches the regex. If
                        None, all events are selected. Default None.
    :param not_regex:   Don't print events whose message matches the regex.
                        Default None.
    :param start_time:  Start time timestamp. Default None.
    :param end_time:    Timestamp for end time for events to print. Default None.

    """

    # Try for a public IP first
    interfaces = aws_context.get_interfaces_by_ip(ip_address, addr_type='public')

    if not interfaces:
        # Try for private IP
        interfaces = aws_context.get_interfaces_by_ip(ip_address, addr_type='private')

        if not interfaces:
            raise Exception(f'IP {ip_address} is not associated with an interface')

    # TODO: Fix the -all
    for i in sorted(interfaces):
        print_stream(
            i + '-all',
            aws_context,
            fmt,
            log_group=log_group,
            regex=regex,
            not_regex=not_regex,
            start_time=start_time,
            end_time=end_time,
        )


# ------------------------------------------------------------------------------
def print_eni_log(
    eni_name: str,
    aws_context: AwsContext,
    fmt: str,
    log_group: str = None,
    regex: str = None,
    not_regex: str = None,
    start_time: Timestamp = None,
    end_time: Timestamp = None,
) -> None:
    """
    Print log events for the network interfaces with the given name (value of Name tag).

    :param eni_name:    ENI name.
    :param aws_context: AWS connection context.
    :param fmt:         A format string
    :param log_group:   Log group name. If None (default) search all log groups.
    :param regex:       Only print events whose message matches the regex. If
                        None, all events are selected. Default None.
    :param not_regex:   Don't print events whose message matches the regex.
                        Default None.
    :param start_time:  Start time timestamp. Default None.
    :param end_time:    Timestamp for end time for events to print. Default None.

    """

    interfaces = aws_context.get_interfaces_by_name(eni_name)

    if not interfaces:
        raise Exception(f'No interfaces named "{eni_name}" found')

    for i in sorted(interfaces):
        print_stream(
            i + '-all',
            aws_context,
            fmt,
            log_group=log_group,
            regex=regex,
            not_regex=not_regex,
            start_time=start_time,
            end_time=end_time,
        )


# ------------------------------------------------------------------------------
def process_cli_args() -> argparse.Namespace:
    """Process the command line arguments."""

    argp = argparse.ArgumentParser(
        prog=PROG, description='Retrieve contents of a log stream from AWS CloudWatch'
    )

    argp.add_argument(
        '-c',
        '--no-colour',
        '--no-color',
        dest='no_colour',
        action='store_true',
        default=False,
        help='Don\'t use colour in information messages.',
    )
    argp.add_argument(
        '-f',
        '--format',
        action='store',
        default=EVENT_PRINT_FORMAT,
        help=f'Format event records. See the manual. Default is "{EVENT_PRINT_FORMAT}"',
    )
    argp.add_argument(
        '-g',
        '--group',
        action='store',
        help='Limit actions to the specified CloudWatch log group.',
    )
    argp.add_argument(
        '-r',
        '--regex',
        action='store',
        help='Only print events whose message matches the given regex.',
    )
    argp.add_argument(
        '-R',
        '--not-regex',
        dest='not_regex',
        action='store',
        help='Don\'t print events whose message matches the given regex.'
        ' This is applied after the -r regex is applied (if present).',
    )

    argp.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='Print more info on AWS CLI commands and other debugging'
        ' level information. Unrelated to the --debug option which'
        ' is passed to the AWS CLI.',
    )

    stream_args_group = argp.add_argument_group(
        title='Log stream selection arguments',
        description='Exactly one of the following arguments is required to select the'
        ' log stream(s) to print.',
    )
    stream_args = stream_args_group.add_mutually_exclusive_group(required=True)
    stream_args.add_argument('-l', '--list', action='store_true', help='List available log streams')
    stream_args.add_argument(
        '-s',
        '--stream',
        action='store',
        help='Look for the specified log stream. If a log group is'
        ' specified with the -g option then only that group'
        ' will be searched, otherwise all log groups will be'
        ' searched and the first matching stream selected.',
    )
    stream_args.add_argument(
        '-i',
        '--instance-log',
        dest='instance_log',
        metavar='NAME',
        action='store',
        help='Look for an EC2 instance with the specified name (Name tag),'
        ' find its instance ID and then look for a stream named'
        ' after the instance ID. This is useful for Linux nodes'
        ' that use AWSlog to deliver syslogs to CloudWatch.',
    )
    stream_args.add_argument(
        '-n',
        '--instance-net',
        dest='instance_net',
        metavar='NAME',
        action='store',
        help='Look for an EC2 instance with the specified name (Name tag),'
        ' find the ID(s) of all network interfaces currently attached'
        ' and look for log streams with names based on the interface'
        ' ID(s). This is useful for locating flow logs related to'
        ' the instance but can be misleading if an interface has'
        ' moved between nodes.',
    )
    stream_args.add_argument(
        '-e',
        '--eni',
        dest='eni_name',
        metavar='NAME',
        action='store',
        help='Look for Elastic Network Interfaces with the specified'
        ' name (Name tag), find their interface IDs and look for'
        ' log streams that start with those IDs. This is useful'
        ' for locating flow logs for an interface.',
    )

    stream_args.add_argument(
        '-p',
        '--ip',
        dest='ip_addr',
        metavar='IP',
        action='store',
        help='Look for Elastic Network Interfaces with the specified'
        ' IP address (public or private), find their interface IDs'
        ' and look for log streams that start with that ID. This'
        ' is useful for locating flow logs for an IP address.',
    )

    time_args = argp.add_argument_group(
        title='Log event date/time arguments',
        description='Each of these can be an integer followed by w, d, h, m, s (weeks,'
        ' days, hours, minutes, seconds) or a date/time in the format'
        ' yyyy-mm-ddTHH:MM:SS (i.e. ISO-8601 like). The dashes and the'
        ' seconds are optional and the T can be a space. e.g. 2015-12-25T16:10:00'
        ' and 20151225 16:10 are equivalent. If start time is after end time'
        ' they will be silently swapped.',
    )
    time_args.add_argument(
        '-S',
        '--start',
        action='store',
        default=DEFAULT_TIME_WINDOW,
        help=f'Start time for the log events to print. Default is {DEFAULT_TIME_WINDOW}.',
    )
    time_args.add_argument(
        '-E',
        '--end',
        action='store',
        help='End time for the log events to print. Default is current time.',
    )

    # Add the AWS CLI standard args.
    for aws_arg in sorted(AWS_ARGS_0):
        argp.add_argument(
            '--' + aws_arg,
            dest=aws_arg.replace('-', '_'),
            action='store_true',
            help='As for AWS CLI.',
        )

    for aws_arg in sorted(AWS_ARGS_1):
        argp.add_argument(
            '--' + aws_arg,
            metavar='arg',
            dest=aws_arg.replace('-', '_'),
            action='store',
            help='As for AWS CLI.',
        )

    return argp.parse_args()


# ------------------------------------------------------------------------------
def main() -> int:
    """
    Show time.

    :return:    Status.
    """

    global COLOUR
    args = process_cli_args()
    COLOUR = not args.no_colour
    setup_logging('debug' if args.verbose else 'info', '', COLOUR)

    # ----------------------------------------
    # Bundle standard AWS CLI args for use in AWD CLI calls.

    aws_cli_args = ['--' + attr for attr in AWS_ARGS_0 if getattr(args, attr.replace('-', '_'))]

    for attr in AWS_ARGS_1:
        value = getattr(args, attr.replace('-', '_'))
        if value is not None:
            aws_cli_args.extend(['--' + attr, value])

    aws_context = AwsContext(aws_cli_args)

    if args.list:
        list_streams(aws_context, log_group=args.group)
        return 0

    start_time = Timestamp(args.start)
    end_time = Timestamp(args.end)
    if start_time > end_time:
        start_time, end_time = end_time, start_time

    if args.stream:
        print_stream(
            args.stream,
            aws_context,
            fmt=args.format,
            log_group=args.group,
            regex=args.regex,
            not_regex=args.not_regex,
            start_time=start_time,
            end_time=end_time,
        )
        return 0

    if args.instance_log:
        print_instance_log(
            args.instance_log,
            aws_context,
            fmt=args.format,
            log_group=args.group,
            regex=args.regex,
            not_regex=args.not_regex,
            start_time=start_time,
            end_time=end_time,
        )
        return 0

    if args.instance_net:
        print_instance_net(
            args.instance_net,
            aws_context,
            fmt=args.format,
            log_group=args.group,
            regex=args.regex,
            not_regex=args.not_regex,
            start_time=start_time,
            end_time=end_time,
        )
        return 0

    if args.ip_addr:
        print_ip_log(
            args.ip_addr,
            aws_context,
            fmt=args.format,
            log_group=args.group,
            regex=args.regex,
            not_regex=args.not_regex,
            start_time=start_time,
            end_time=end_time,
        )
        return 0

    if args.eni_name:
        print_eni_log(
            args.eni_name,
            aws_context,
            fmt=args.format,
            log_group=args.group,
            regex=args.regex,
            not_regex=args.not_regex,
            start_time=start_time,
            end_time=end_time,
        )
        return 0

    raise Exception('Interossiter malfunction')


# ------------------------------------------------------------------------------
if __name__ == '__main__':
    # Uncomment for debugging
    # exit(main())  # noqa: ERA001
    try:
        exit(main())
    except Exception as ex:
        LOG.error('%s', ex)
        exit(1)
    except KeyboardInterrupt:
        LOG.warning('Interrupt')
        exit(2)
